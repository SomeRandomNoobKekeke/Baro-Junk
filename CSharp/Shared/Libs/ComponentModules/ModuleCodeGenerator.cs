using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;

using Barotrauma;
using Microsoft.Xna.Framework;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace BaroJunk
{

  public static class ModuleCodeGenerator
  {
    public static IEnumerable<string> GenerateInjectCode(IComponent host)
      => GenerateInjectCode(ModuleMap.GetFor(host.GetType()));

    public static IEnumerable<string> GenerateInjectCode(Type T)
      => GenerateInjectCode(ModuleMap.GetFor(T));

    public static IEnumerable<string> GenerateInjectCode(ModuleMap map)
    {
      foreach (string line in GenerateHostInjectionCode(
        ModuleMapAnalizer.CreateInjectHostInstructions(map))
      ) yield return line;

      foreach (string line in GenerateDependencyInjectionCode(
        ModuleMapAnalizer.CreateInjectDependencyInstructions(map))
      ) yield return line;
    }

    public static IEnumerable<string> GenerateHostInjectionCode(IEnumerable<InjectHostInstruction> instructions)
    {
      foreach (var instruction in instructions)
      {
        yield return $"{String.Join('.', instruction.FullPath.Select(pi => pi.Name))}.{instruction.HostProp.Name} = this;";
      }
    }

    public static IEnumerable<string> GenerateDependencyInjectionCode(IEnumerable<InjectDependencyInstruction> instructions)
    {
      foreach (var instruction in instructions)
      {
        yield return $"{String.Join('.', instruction.TargetPath.Select(pi => pi.Name))}.{instruction.Property.Name} = {String.Join('.', instruction.DependencyPath.Select(pi => pi.Name))};";
      }
    }


    static ModuleCodeGenerator()
    {
      PluginLifeCycle.End += () => TargetFiles.Clear();
      PluginCommands.Add("generatecode", (args) => ModuleCodeGenerator.GenarateAll());
    }


    public static bool TrackGenerateCalls = true;

    public static void GenarateAll()
    {
      foreach (TargetFile file in TargetFiles.Values)
      {
        if (file is null) continue;

        GenerateForFile(file.T, file.sourceFilePath, file.sourceLineNumber);
      }
    }

    /// <summary>
    /// This just adds file to TargetFiles dics
    /// To generate code you need to also call GenarateAll()
    /// Target method should have [MethodImpl(MethodImplOptions.NoInlining)]
    /// </summary>
    public static void GenerateInjectCodeHere([CallerFilePath] string sourceFilePath = "", [CallerLineNumber] int sourceLineNumber = 0)
    {
      if (!TrackGenerateCalls) return;

      string source = $"{sourceFilePath}:{sourceLineNumber}";

      if (TargetFiles.ContainsKey(source)) return; // already targeted

      MethodBase callingMethod = new StackFrame(1).GetMethod();

      if (!callingMethod.DeclaringType.IsAssignableTo(typeof(IComponent)))
      {
        ModuleManager.Logger.Warning($"{sourceFilePath}: {sourceLineNumber}");
        ModuleManager.Logger.Warning($"Wtf is this? [{callingMethod.DeclaringType}] is not an IComponent");
        TargetFiles[source] = null;
        return;
      }

      TargetFiles[source] = new TargetFile(callingMethod.DeclaringType, sourceFilePath, sourceLineNumber);
    }

    private static Dictionary<string, TargetFile> TargetFiles = new();

    private record TargetFile(Type T, string sourceFilePath, int sourceLineNumber);

    private static void GenerateForFile(Type T, string sourceFilePath, int sourceLineNumber)
    {
      string GenerateInjectCodeHereCall = "ModuleCodeGenerator.GenerateInjectCodeHere();";
      string AutogeneradedStart = "//================> Autogenerated <================";
      string AutogeneradedEnd = "//================< Autogenerated >================";
      string regexPattern = $"ModuleCodeGenerator\\.GenerateInjectCodeHere\\(\\);.*{AutogeneradedEnd}";

      string code = File.ReadAllText(sourceFilePath);

      string callingLine = code.Split('\n')[sourceLineNumber - 1];
      string indent = new string(' ', callingLine.Length - callingLine.TrimStart().Length);


      List<string> generated = new();

      generated.Add(GenerateInjectCodeHereCall);
      generated.Add($"{indent}{AutogeneradedStart}");
      generated.AddRange(GenerateInjectCode(T).Select(s => $"{indent}{s}"));
      generated.Add($"{indent}{AutogeneradedEnd}");

      if (Regex.IsMatch(code, regexPattern, RegexOptions.Singleline))
      {
        code = Regex.Replace(code, regexPattern, string.Join('\n', generated), RegexOptions.Singleline);
      }
      else
      {
        code = code.Replace(GenerateInjectCodeHereCall, string.Join('\n', generated));
      }

      File.WriteAllText(sourceFilePath, code);
    }




  }


}
