using System;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;

using Barotrauma;
using Microsoft.Xna.Framework;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace BaroJunk
{

  public static class ModuleCodeGenerator
  {
    public static IEnumerable<string> GenerateInjectCode(IComponent host)
      => GenerateInjectCode(ModuleMap.GetFor(host.GetType()));

    public static IEnumerable<string> GenerateInjectCode(Type T)
      => GenerateInjectCode(ModuleMap.GetFor(T));

    public static IEnumerable<string> GenerateInjectCode(ModuleMap map)
    {
      foreach (string line in GenerateHostInjectionCode(
        ModuleMapAnalizer.CreateInjectHostInstructions(map))
      ) yield return line;

      foreach (string line in GenerateDependencyInjectionCode(
        ModuleMapAnalizer.CreateInjectDependencyInstructions(map))
      ) yield return line;
    }

    public static IEnumerable<string> GenerateHostInjectionCode(IEnumerable<InjectHostInstruction> instructions)
    {
      foreach (var instruction in instructions)
      {
        yield return $"{String.Join('.', instruction.FullPath.Select(pi => pi.Name))}.{instruction.HostProp.Name} = this;";
      }
    }

    public static IEnumerable<string> GenerateDependencyInjectionCode(IEnumerable<InjectDependencyInstruction> instructions)
    {
      foreach (var instruction in instructions)
      {
        yield return $"{String.Join('.', instruction.TargetPath.Select(pi => pi.Name))}.{instruction.Property.Name} = {String.Join('.', instruction.DependencyPath.Select(pi => pi.Name))};";
      }
    }



    /// <summary>
    /// This will probably work only in barotrauma "in memory" c# mods
    /// Note: target method should have [MethodImpl(MethodImplOptions.NoInlining)]
    /// </summary>
    public static void GenerateInjectCodeHere([CallerFilePath] string sourceFilePath = "", [CallerLineNumber] int sourceLineNumber = 0)
    {
      string GenerateInjectCodeHereCall = "ModuleCodeGenerator.GenerateInjectCodeHere();";
      string AutogeneradedStart = "//================> Autogenerated <================";
      string AutogeneradedEnd = "//================< Autogenerated >================";
      string regexPattern = $"ModuleCodeGenerator\\.GenerateInjectCodeHere\\(\\);.*{AutogeneradedEnd}";

      MethodBase callingMethod = new StackFrame(1).GetMethod();

      if (!callingMethod.DeclaringType.IsAssignableTo(typeof(IComponent)))
      {
        ModuleManager.Logger.Warning($"{sourceFilePath}: {sourceLineNumber}");
        ModuleManager.Logger.Warning($"Wtf is this? [{callingMethod.DeclaringType}] is not an IComponent");
        return;
      }

      string code = File.ReadAllText(sourceFilePath);

      string callingLine = code.Split('\n')[sourceLineNumber - 1];
      string indent = new string(' ', callingLine.Length - callingLine.TrimStart().Length);


      List<string> generated = new();

      generated.Add(GenerateInjectCodeHereCall);
      generated.Add($"{indent}{AutogeneradedStart}");
      generated.AddRange(GenerateInjectCode(callingMethod.DeclaringType).Select(s => $"{indent}{s}"));
      generated.Add($"{indent}{AutogeneradedEnd}");

      if (Regex.IsMatch(code, regexPattern, RegexOptions.Singleline))
      {
        code = Regex.Replace(code, regexPattern, string.Join('\n', generated), RegexOptions.Singleline);
      }
      else
      {
        code = code.Replace(GenerateInjectCodeHereCall, string.Join('\n', generated));
      }

      File.WriteAllText(sourceFilePath, code);
    }


  }


}
